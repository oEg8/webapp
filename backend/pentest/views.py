import ipaddress
import json
import secrets
from django.contrib.auth import authenticate, get_user_model
from django.http import JsonResponse, HttpResponseBadRequest, HttpResponseNotAllowed
from django.utils import timezone
from django.views.decorators.csrf import csrf_exempt

from .engines import get_engine, list_engines
from .models import AuthToken, PentestRequest, PentestScan, UserProfile


OFFERINGS = [
    {"id": "web", "name": "Web Application Pentest", "description": "OWASP-based review of web applications."},
    {"id": "api", "name": "API Security Review", "description": "Authentication, authorization, and input validation coverage."},
    {"id": "cloud", "name": "Cloud Configuration Review", "description": "Best-practice review of cloud accounts and IAM posture."},
]

MFA_CODE_TTL_SECONDS = 600
WORKDAY_START_HOUR = 9
WORKDAY_END_HOUR = 17


def json_error(message, status=400):
    return JsonResponse({"error": message}, status=status)


def parse_json(request):
    try:
        return json.loads(request.body.decode("utf-8"))
    except json.JSONDecodeError:
        return None


def issue_token(user):
    key = secrets.token_hex(20)
    AuthToken.objects.create(user=user, key=key)
    return key


def get_auth_user(request):
    auth_header = request.headers.get("Authorization", "")
    if not auth_header.startswith("Bearer "):
        return None
    token = auth_header.replace("Bearer ", "", 1).strip()
    if not token:
        return None
    try:
        token_obj = AuthToken.objects.select_related("user").get(key=token)
    except AuthToken.DoesNotExist:
        return None
    return token_obj.user


def require_auth(request):
    user = get_auth_user(request)
    if not user:
        return None, json_error("Unauthorized", status=401)
    return user, None


def validate_target_ip(raw_value):
    try:
        return str(ipaddress.ip_address(raw_value))
    except ValueError:
        return None


def parse_bool(value):
    if isinstance(value, bool):
        return value
    if isinstance(value, int):
        return value != 0
    if isinstance(value, str):
        return value.strip().lower() in {"true", "1", "yes", "on"}
    return False


def offerings(request):
    if request.method != "GET":
        return HttpResponseNotAllowed(["GET"])
    return JsonResponse({"offerings": OFFERINGS})


@csrf_exempt
def requests_list(request):
    if request.method == "GET":
        data = [req.as_dict() for req in PentestRequest.objects.all()]
        return JsonResponse({"requests": data})

    if request.method == "POST":
        payload = parse_json(request)
        if payload is None:
            return HttpResponseBadRequest("Invalid JSON")

        required_fields = ["client_name", "contact_email", "scope"]
        if any(not payload.get(field) for field in required_fields):
            return HttpResponseBadRequest("client_name, contact_email, and scope are required.")

        pentest_request = PentestRequest.objects.create(
            client_name=payload["client_name"],
            contact_email=payload["contact_email"],
            scope=payload["scope"],
            preferred_window=payload.get("preferred_window", ""),
        )
        return JsonResponse(pentest_request.as_dict(), status=201)

    return HttpResponseNotAllowed(["GET", "POST"])


@csrf_exempt
def request_detail(request, pk):
    try:
        pentest_request = PentestRequest.objects.get(pk=pk)
    except PentestRequest.DoesNotExist:
        return JsonResponse({"error": "Not found"}, status=404)

    if request.method == "GET":
        return JsonResponse(pentest_request.as_dict())

    if request.method in {"PATCH", "PUT"}:
        payload = parse_json(request)
        if payload is None:
            return HttpResponseBadRequest("Invalid JSON")

        if "status" in payload:
            pentest_request.status = payload["status"]
        if "preferred_window" in payload:
            pentest_request.preferred_window = payload["preferred_window"]
        pentest_request.save()
        return JsonResponse(pentest_request.as_dict())

    return HttpResponseNotAllowed(["GET", "PATCH", "PUT"])


@csrf_exempt
def register(request):
    if request.method != "POST":
        return HttpResponseNotAllowed(["POST"])

    payload = parse_json(request)
    if payload is None:
        return HttpResponseBadRequest("Invalid JSON")

    username = (payload.get("username") or "").strip()
    password = payload.get("password") or ""
    email = (payload.get("email") or "").strip()
    target_ip = validate_target_ip(payload.get("target_ip"))

    if not username or not password or not target_ip:
        return json_error("username, password, and target_ip are required.")

    User = get_user_model()
    if User.objects.filter(username=username).exists():
        return json_error("Username already exists.")

    user = User.objects.create_user(username=username, password=password, email=email)
    mfa_enabled = parse_bool(payload.get("mfa_enabled", False))
    profile = UserProfile.objects.create(user=user, target_ip=target_ip, mfa_enabled=mfa_enabled)

    token = issue_token(user)
    return JsonResponse(
        {
            "user": {"id": user.id, "username": user.username, "email": user.email},
            "profile": profile.as_dict(),
            "token": token,
            "mfa_required": False,
            "mfa_code": None,
        },
        status=201,
    )


@csrf_exempt
def login(request):
    if request.method != "POST":
        return HttpResponseNotAllowed(["POST"])

    payload = parse_json(request)
    if payload is None:
        return HttpResponseBadRequest("Invalid JSON")

    username = payload.get("username") or ""
    password = payload.get("password") or ""
    if not username or not password:
        return json_error("username and password are required.")

    user = authenticate(username=username, password=password)
    if not user:
        return json_error("Invalid credentials.", status=401)

    try:
        profile = user.profile
    except UserProfile.DoesNotExist:
        return json_error("User profile missing. Please register again.", status=400)

    if profile.mfa_enabled:
        code = f"{secrets.randbelow(10**6):06d}"
        profile.mfa_code = code
        profile.mfa_code_created_at = timezone.now()
        profile.save(update_fields=["mfa_code", "mfa_code_created_at"])
        return JsonResponse(
            {
                "mfa_required": True,
                "mfa_code": code,
                "username": user.username,
            }
        )

    token = issue_token(user)
    return JsonResponse(
        {
            "mfa_required": False,
            "token": token,
            "user": {"id": user.id, "username": user.username, "email": user.email},
            "profile": profile.as_dict(),
        }
    )


@csrf_exempt
def mfa_verify(request):
    if request.method != "POST":
        return HttpResponseNotAllowed(["POST"])

    payload = parse_json(request)
    if payload is None:
        return HttpResponseBadRequest("Invalid JSON")

    username = payload.get("username") or ""
    code = payload.get("code") or ""
    if not username or not code:
        return json_error("username and code are required.")

    User = get_user_model()
    try:
        user = User.objects.get(username=username)
        profile = user.profile
    except (User.DoesNotExist, UserProfile.DoesNotExist):
        return json_error("User not found.", status=404)

    if not profile.mfa_enabled:
        return json_error("MFA is not enabled for this account.", status=400)

    if not profile.mfa_code or profile.mfa_code != code:
        return json_error("Invalid MFA code.", status=401)

    if profile.mfa_code_created_at is None:
        return json_error("MFA code expired.", status=401)

    age = timezone.now() - profile.mfa_code_created_at
    if age.total_seconds() > MFA_CODE_TTL_SECONDS:
        return json_error("MFA code expired.", status=401)

    profile.mfa_code = ""
    profile.mfa_code_created_at = None
    profile.save(update_fields=["mfa_code", "mfa_code_created_at"])

    token = issue_token(user)
    return JsonResponse(
        {
            "token": token,
            "user": {"id": user.id, "username": user.username, "email": user.email},
            "profile": profile.as_dict(),
        }
    )


def me(request):
    if request.method != "GET":
        return HttpResponseNotAllowed(["GET"])

    user, error = require_auth(request)
    if error:
        return error

    profile = user.profile
    return JsonResponse(
        {
            "user": {"id": user.id, "username": user.username, "email": user.email},
            "profile": profile.as_dict(),
        }
    )


@csrf_exempt
def pentest_scan(request):
    if request.method != "POST":
        return HttpResponseNotAllowed(["POST"])

    user, error = require_auth(request)
    if error:
        return error

    try:
        profile = user.profile
    except UserProfile.DoesNotExist:
        return json_error("User profile missing. Please register again.", status=400)

    target_ip = validate_target_ip(profile.target_ip)
    if not target_ip:
        return json_error("Invalid target IP on profile.", status=400)

    now = timezone.localtime(timezone.now())
    if not (WORKDAY_START_HOUR <= now.hour < WORKDAY_END_HOUR):
        return json_error("Scans are only allowed between 09:00 and 17:00.", status=403)

    if profile.credits < 1:
        return json_error("Insufficient credits.", status=402)

    profile.credits -= 1
    profile.save(update_fields=["credits"])

    payload = parse_json(request)
    if payload is None:
        payload = {}

    engine_name = payload.get("engine") or "nmap"
    engine = get_engine(engine_name)
    if not engine:
        return json_error(f"Unknown engine '{engine_name}'. Available: {', '.join(list_engines())}.", status=400)

    scan = PentestScan.objects.create(
        user=user,
        target_ip=target_ip,
        engine=engine.name,
        status=PentestScan.STATUS_RUNNING,
    )

    result = engine.run(target_ip)
    scan.output = result.get("output", "")
    scan.status = result.get("status", PentestScan.STATUS_FAILED)
    scan.save(update_fields=["output", "status"])
    response = scan.as_dict()
    response["credits"] = profile.credits
    return JsonResponse(response)


def pentest_scans(request):
    if request.method != "GET":
        return HttpResponseNotAllowed(["GET"])

    user, error = require_auth(request)
    if error:
        return error

    scans = [scan.as_dict() for scan in PentestScan.objects.filter(user=user)]
    return JsonResponse({"scans": scans})


def pentest_engines(request):
    if request.method != "GET":
        return HttpResponseNotAllowed(["GET"])
    return JsonResponse({"engines": list_engines()})
